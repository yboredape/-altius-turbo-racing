<!DOCTYPE html>
<!--
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë           üîí SECURITY & PRIVACY NOTICE üîí                    ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    
    This game is 100% client-side and completely safe:
    
    ‚úÖ No server communication
    ‚úÖ No external scripts or libraries  
    ‚úÖ No tracking or analytics
    ‚úÖ No ads or monetization code
    ‚úÖ No personal data collection
    ‚úÖ No cookies
    
    ONLY USES:
    ‚Ä¢ HTML5 Canvas (graphics rendering)
    ‚Ä¢ Web Audio API (sound effects)
    ‚Ä¢ localStorage (saves high score locally on YOUR device)
    
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    üîç HOW TO VERIFY SAFETY YOURSELF:
    
    1. Press Ctrl+U (Windows) or Cmd+Option+U (Mac) to view source
    2. Press Ctrl+F to search
    3. Search for these terms - you won't find them:
       ‚Ä¢ fetch(
       ‚Ä¢ XMLHttpRequest
       ‚Ä¢ websocket
       ‚Ä¢ document.cookie
       ‚Ä¢ eval(
       ‚Ä¢ <script src=
    
    All code is in this single HTML file below.
    Read it, audit it, verify it yourself!
    
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    Made with ‚ù§Ô∏è and vanilla JavaScript
    No frameworks, no dependencies, no BS.
    
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Altius Turbo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            background: #1a1a2e;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            position: relative;
        }

        .header {
            background: linear-gradient(90deg, #ff6b6b, #FF6347);
            padding: 10px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 13px;
        }

        .score {
            font-size: 13px;
        }

        .lives {
            font-size: 13px;
            letter-spacing: 2px;
        }

        .speed {
            font-size: 13px;
            opacity: 0.9;
        }

        canvas {
            display: block;
            background: #2d2d44;
            touch-action: none;
        }

        .game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.97);
            padding: 24px 20px 20px;
            border-radius: 20px;
            text-align: center;
            color: white;
            display: none;
            border: 3px solid #ff6b6b;
            width: 360px;
        }

        .game-over-screen.show {
            display: block;
        }

        .game-over-screen h2 {
            font-size: 38px;
            margin-bottom: 10px;
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin: 10px 0 12px;
        }

        .summary-card {
            background: rgba(255,255,255,0.07);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 10px;
            padding: 8px 4px 6px;
            text-align: center;
        }

        .summary-icon { font-size: 18px; line-height: 1; }
        .summary-val  { font-size: 15px; font-weight: bold; color: #ffd700; margin: 3px 0 2px; }
        .summary-label{ font-size: 9px; opacity: 0.65; text-transform: uppercase; letter-spacing: 0.5px; }

        .game-over-screen p {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .btn {
            background: linear-gradient(90deg, #ff6b6b, #FF6347);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            border: 3px solid #FF6347;
        }

        .start-screen h1 {
            font-size: 56px;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #ff6b6b, #FF6347);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .start-screen p {
            font-size: 18px;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .controls {
            margin-top: 20px;
            font-size: 14px;
            opacity: 0.7;
        }

        .car-card {
            background: rgba(255,255,255,0.08);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 10px 8px 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .car-card:hover {
            background: rgba(255,255,255,0.15);
            border-color: #FF6347;
            transform: translateY(-3px);
        }

        .car-card.selected {
            border-color: #ffd700;
            background: rgba(255,215,0,0.15);
            box-shadow: 0 0 12px rgba(255,215,0,0.4);
        }

    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="score">Score: <span id="scoreDisplay">0</span></div>
            <div class="score">üèÜ <span id="highScoreDisplay">0</span></div>
            <div class="score">ü™ô <span id="coinDisplay">0</span></div>
            <div class="score" id="powerUpIndicator" style="display:none;"></div>
            <div class="lives"><span id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
            <div class="speed"><span id="levelDisplay">‚≠ê Rookie</span></div>
            <div class="speed">Speed: <span id="speedDisplay">0</span> km/h</div>
        </div>
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        
        <div class="start-screen" id="startScreen">
            <h1>üèéÔ∏è ALTIUS TURBO</h1>
            <p>Dodge the traffic and race to the top score!</p>
            <p style="font-size:14px; margin-bottom:10px; color:#ffd700;">Choose your car:</p>

            <div style="display:flex; justify-content:center; gap:14px; margin-bottom:18px;">
                <div class="car-card" id="carCard0" onclick="selectCar(0)">
                    <canvas id="carPreview0" width="60" height="100"></canvas>
                </div>
                <div class="car-card" id="carCard1" onclick="selectCar(1)">
                    <canvas id="carPreview1" width="60" height="100"></canvas>
                </div>
                <div class="car-card" id="carCard2" onclick="selectCar(2)">
                    <canvas id="carPreview2" width="60" height="100"></canvas>
                </div>
            </div>

            <button class="btn" onclick="startGame()">START RACE</button>
            
            <!-- Safety & Transparency Buttons -->
            <div style="margin-top: 14px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                <button onclick="openSafetyModal()" style="
                    background: rgba(0,255,136,0.15);
                    color: #00ff88;
                    border: 1.5px solid #00ff88;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 11px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.2s;
                " onmouseover="this.style.background='rgba(0,255,136,0.25)'" 
                   onmouseout="this.style.background='rgba(0,255,136,0.15)'">
                    üîí Safety Info
                </button>
                
                <button onclick="viewSourceCode()" style="
                    background: rgba(255,215,0,0.15);
                    color: #ffd700;
                    border: 1.5px solid #ffd700;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 11px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.2s;
                " onmouseover="this.style.background='rgba(255,215,0,0.25)'" 
                   onmouseout="this.style.background='rgba(255,215,0,0.15)'">
                    üîç View Source Code
                </button>
            </div>

            <div class="controls">
                PC: ‚Üê ‚Üí or A/D to switch lanes &nbsp;|&nbsp; SPACE for üöÄ Turbo<br>
                Mobile: Swipe left/right to switch lanes &nbsp;|&nbsp; Double-tap for üöÄ Turbo
            </div>
        </div>

        <!-- Safety & Privacy Modal -->
        <div id="safetyModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); z-index:9999; overflow:auto;">
            <div style="max-width:650px; margin:40px auto; background:#1a1a2e; padding:35px; border-radius:16px; color:#fff; box-shadow:0 10px 50px rgba(0,0,0,0.5);">
                <h2 style="color:#00ff88; margin-top:0;">üîí Safety & Privacy</h2>
                
                <h3 style="color:#ffd700; font-size:16px;">‚úÖ What This Game Does:</h3>
                <ul style="line-height:1.8; color:#ccc;">
                    <li>Runs 100% in your browser (client-side only)</li>
                    <li>Saves high score using localStorage (on your device only)</li>
                    <li>Uses HTML5 Canvas for graphics</li>
                    <li>Uses Web Audio API for sounds</li>
                </ul>

                <h3 style="color:#ffd700; font-size:16px;">‚ùå What This Game Does NOT Do:</h3>
                <ul style="line-height:1.8; color:#ccc;">
                    <li>Connect to any servers</li>
                    <li>Track your activity or collect analytics</li>
                    <li>Collect any personal data</li>
                    <li>Use cookies or third-party scripts</li>
                    <li>Load external resources</li>
                    <li>Send data anywhere</li>
                </ul>

                <h3 style="color:#ffd700; font-size:16px;">üîç How to Verify Yourself:</h3>
                <ol style="line-height:1.8; color:#ccc;">
                    <li>Right-click anywhere on this page ‚Üí Select <strong>"View Page Source"</strong><br>
                        <em style="font-size:12px; color:#888;">(Or press Ctrl+U on Windows, Cmd+Option+U on Mac)</em>
                    </li>
                    <li>Press <strong>Ctrl+F</strong> (or Cmd+F) to search</li>
                    <li>Search for these suspicious terms:
                        <ul style="margin-top:8px;">
                            <li><code style="background:#0a0a0a; padding:2px 6px; border-radius:3px; color:#ff6666;">fetch(</code> ‚Üí <span style="color:#00ff88;">Not found ‚úì</span></li>
                            <li><code style="background:#0a0a0a; padding:2px 6px; border-radius:3px; color:#ff6666;">XMLHttpRequest</code> ‚Üí <span style="color:#00ff88;">Not found ‚úì</span></li>
                            <li><code style="background:#0a0a0a; padding:2px 6px; border-radius:3px; color:#ff6666;">websocket</code> ‚Üí <span style="color:#00ff88;">Not found ‚úì</span></li>
                            <li><code style="background:#0a0a0a; padding:2px 6px; border-radius:3px; color:#ff6666;">document.cookie</code> ‚Üí <span style="color:#00ff88;">Not found ‚úì</span></li>
                        </ul>
                    </li>
                </ol>

                <div style="background:rgba(0,255,136,0.1); padding:15px; border-radius:8px; border-left:4px solid #00ff88; margin:20px 0;">
                    <p style="margin:0; color:#88ffcc; font-size:14px;">
                        <strong>üí° Bottom line:</strong> All code is visible in one HTML file. 
                        No hidden components, no obfuscation, no tricks. What you see is what you get.
                    </p>
                </div>

                <button onclick="closeSafetyModal()" style="background:#00ff88; color:#000; border:none; padding:12px 28px; border-radius:8px; font-weight:bold; cursor:pointer; margin-top:10px; font-size:14px; transition:all 0.2s;">
                    Got It! Let's Race üèéÔ∏è
                </button>
            </div>
        </div>

        <div class="game-over-screen" id="gameOverScreen">
            <h2>GAME OVER!</h2>
            <p id="newHighScoreMsg" style="color:#feca57; font-weight:bold; display:none; margin:0 0 8px;">üèÜ NEW HIGH SCORE!</p>

            <div class="summary-grid">
                <div class="summary-card">
                    <div class="summary-icon">üèÅ</div>
                    <div class="summary-val" id="finalScore">0</div>
                    <div class="summary-label">Score</div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">üèÜ</div>
                    <div class="summary-val" id="finalHighScore">0</div>
                    <div class="summary-label">Best</div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">‚≠ê</div>
                    <div class="summary-val" id="finalLevel">Rookie</div>
                    <div class="summary-label">Level</div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">üí®</div>
                    <div class="summary-val" id="finalTopSpeed">0</div>
                    <div class="summary-label">Top Speed</div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">ü™ô</div>
                    <div class="summary-val" id="finalCoins">0</div>
                    <div class="summary-label">Coins</div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">üòÖ</div>
                    <div class="summary-val" id="finalCloseCall">0</div>
                    <div class="summary-label">Close Calls</div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">‚è±Ô∏è</div>
                    <div class="summary-val" id="finalTime">0s</div>
                    <div class="summary-label">Run Time</div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">ü™ô</div>
                    <div class="summary-val" id="finalCPM">0</div>
                    <div class="summary-label">Coins/min</div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">üî•</div>
                    <div class="summary-val" id="finalBestCombo">0</div>
                    <div class="summary-label">Best Combo</div>
                </div>
            </div>

            <div id="runRating" style="font-size:22px; margin: 10px 0 4px;"></div>
            <div id="roastMsg" style="font-size:13px; color:#ff9999; font-style:italic; min-height:18px; margin-bottom:10px;"></div>
            <button class="btn" onclick="restartGame()">RACE AGAIN</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const coinDisplay = document.getElementById('coinDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const speedDisplay = document.getElementById('speedDisplay');
        const finalScoreDisplay   = document.getElementById('finalScore');
        const finalLevelDisplay   = document.getElementById('finalLevel');
        const finalCoinsDisplay   = document.getElementById('finalCoins');
        const finalHighScoreDisplay = document.getElementById('finalHighScore');
        const finalTopSpeedDisplay  = document.getElementById('finalTopSpeed');
        const finalCloseCallDisplay = document.getElementById('finalCloseCall');
        const finalTimeDisplay      = document.getElementById('finalTime');
        const finalCPMDisplay       = document.getElementById('finalCPM');
        const finalBestComboDisplay = document.getElementById('finalBestCombo');
        const runRatingDisplay      = document.getElementById('runRating');
        const roastMsgDisplay       = document.getElementById('roastMsg');
        const newHighScoreMsg       = document.getElementById('newHighScoreMsg');

        // Run stats tracking
        let topSpeed = 0;
        let closeCallCount = 0;
        let runStartTime = 0;
        const powerUpIndicator = document.getElementById('powerUpIndicator');

        let gameStarted = false;
        let gameOver = false;
        let score = 0;
        let coins = 0;
        let lives = 3;
        let invincible = false;
        let invincibleTimer = 0;
        const invincibleDuration = 120;
        let speed = 60;
        let roadOffset = 0;

        // Load high score from localStorage
        let highScore = parseInt(localStorage.getItem('altiusTurboHighScore')) || 0;
        highScoreDisplay.textContent = highScore;

        // Load Altius logo
        const altiusLogo = new Image();
        altiusLogo.src = 'data:image/jpeg;base64,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';
        let logoLoaded = false;
        altiusLogo.onload = () => { logoLoaded = true; };

        // ---- SOUND ENGINE (Web Audio API) ----
        let audioCtx = null;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playCoinSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.08);
            gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.18);
        }

        function playCrashSound() {
            if (!audioCtx) return;
            // Low boom
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(180, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.35);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.35);

            // Noise crackle layer
            const bufferSize = audioCtx.sampleRate * 0.25;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
            const noise = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            noise.buffer = buffer;
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noiseGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
            noise.start(audioCtx.currentTime);
        }

        function playLevelUpSound() {
            if (!audioCtx) return;
            const notes = [523, 659, 784, 1047]; // C E G C
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                const t = audioCtx.currentTime + i * 0.1;
                osc.frequency.setValueAtTime(freq, t);
                gain.gain.setValueAtTime(0.15, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
                osc.start(t);
                osc.stop(t + 0.25);
            });
        }

        function playPowerUpSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(440, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.2);
            osc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.35);
            gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.4);
        }

        

        // Player car
        const player = {
            y: canvas.height - 120,
            width: 40,
            height: 70,
            color: '#FF6347',
            currentLane: 1
        };

        // Smooth lane switching
        let targetLane = 1;
        let laneTransitionSpeed = 0.25; // 0-1, higher = faster
        let carTilt = 0; // visual tilt angle

        // Road lanes
        const laneWidth = canvas.width / 3;
        const lanes = [laneWidth / 2, canvas.width / 2, canvas.width - laneWidth / 2];
        player.x = lanes[1] - player.width / 2;

        // Obstacles
        let obstacles = [];
        let obstacleTimer = 0;
        const obstacleInterval = 100;

        // Coins
        let coinItems = [];
        let coinTimer = 0;
        const coinInterval = 60;

        // Floating text particles
        let floatingTexts = [];

        // Explosion particles
        let particles = [];

        // Exhaust trail
        let exhaustPuffs = [];

        // Skid marks (tyre rubber on lane changes)
        let skidMarks = [];

        // Turbo fire trails
        let turboTrails = [];

        // Coin combo
        let coinCombo = 0;
        let comboTimer = 0;
        const comboWindow = 180; // frames before combo resets (~3s)
        let bestCombo = 0;

        // Screen shake
        let shakeAmount = 0;
        let shakeDuration = 0;

        // Time scale (shared by slow-mo + turbo)
        let timeScale = 1.0;

        // Slow-mo near miss
        let slowMoTimer = 0;
        const slowMoDuration = 40; // frames at slow speed
        const slowMoScale   = 0.28;

        // Turbo boost
        let turboActive  = false;
        let turboTimer   = 0;
        const turboDuration = 120; // 2 seconds
        const turboScale    = 2.2;
        let turboCharge  = 0;       // 0‚Äì100
        const turboMaxCharge = 100;
        const turboChargeRate = 100 / 1200; // fills in ~20s

        // Car selection
        let selectedCar = 0;
        const carConfigs = [
            { name: 'Lamborghini', body: '#1a1a2e', accent: '#FF6347', spoiler: '#cc3300',  glass: '#48dbfb' },
            { name: 'F1 Racer',    body: '#0a0a0a', accent: '#00e5ff', spoiler: '#006080',  glass: '#00e5ff' },
            { name: 'Hypercar',    body: '#1a0500', accent: '#ffcc00', spoiler: '#ff6600',  glass: '#ffe57a' },
        ];
        const weatherStates = ['day', 'night', 'rain'];
        let weatherIndex = 0;
        let weatherTimer = 0;
        const weatherDuration = 900; // ~15s per phase at 60fps
        let nightAlpha = 0;   // 0=bright, 1=dark
        let rainAlpha = 0;    // 0=dry, 1=full rain
        let raindrops = [];
        let weatherLabel = '';
        let weatherLabelTimer = 0;

        // Level system
        let level = 1;
        let levelFlash = 0;
        const levelNames = ['', 'Rookie', 'Racer', 'Pro Racer', 'Elite', 'Altius Pro üèÜ'];
        const levelThresholds = [0, 0, 100, 200, 350, 500];

        // Power-ups
        let powerUps = [];
        let powerUpTimer = 0;
        const powerUpInterval = 600; // appears every ~10 seconds
        let shieldActive = false;
        let shieldTimer = 0;
        let magnetActive = false;
        let magnetTimer = 0;
        const powerUpDuration = 300; // 5 seconds

        // Road hazards
        let hazards = [];
        let hazardTimer = 0;
        const hazardInterval = 900; // spawn less frequently than power-ups
        let oilSlipTimer = 0; // player slides when > 0
        let potholeSlowTimer = 0; // player slows when > 0

        // Controls
        let hasSwitchedLane = false;

        // Keyboard controls
        function activateTurbo() {
            if (!gameStarted || gameOver || turboActive || turboCharge < turboMaxCharge) return;
            turboActive = true;
            turboTimer = turboDuration;
            turboCharge = 0;
            slowMoTimer = 0; // cancel any slow-mo
            spawnFloatingText(player.x + player.width / 2, player.y - 20, 'üöÄ TURBO!', '#ff6600');
        }

        window.addEventListener('keydown', (e) => {
            if (!gameStarted || gameOver) return;
            if (oilSlipTimer > 0) {
                e.preventDefault();
                return; // can't switch lanes while slipping
            }
            if ((e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') && player.currentLane > 0) {
                player.currentLane--;
                targetLane = player.currentLane;
                createSkidMark();
            }
            else if ((e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') && player.currentLane < 2) {
                player.currentLane++;
                targetLane = player.currentLane;
                createSkidMark();
            }
            else if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                activateTurbo();
            }
            e.preventDefault();
        });

        // Touch controls
        let touchStartX = 0;
        let lastTapTime = 0;
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            hasSwitchedLane = false;
            // Double-tap to activate turbo
            const now = Date.now();
            if (now - lastTapTime < 300) activateTurbo();
            lastTapTime = now;
            e.preventDefault();
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!gameStarted || gameOver || hasSwitchedLane || oilSlipTimer > 0) return;
            
            const touchCurrentX = e.touches[0].clientX;
            const touchDiff = touchCurrentX - touchStartX;
            
            if (touchDiff < -30 && player.currentLane > 0) {
                player.currentLane--;
                targetLane = player.currentLane;
                createSkidMark();
                hasSwitchedLane = true;
            }
            else if (touchDiff > 30 && player.currentLane < 2) {
                player.currentLane++;
                targetLane = player.currentLane;
                createSkidMark();
                hasSwitchedLane = true;
            }
            e.preventDefault();
        });

        function selectCar(index) {
            selectedCar = index;
            for (let i = 0; i < 3; i++) {
                document.getElementById(`carCard${i}`).classList.toggle('selected', i === index);
            }
        }

        function renderCarPreviews() {
            const drawFns = [drawLamboCar, drawF1Car, drawHyperCar];
            for (let i = 0; i < 3; i++) {
                const previewCanvas = document.getElementById(`carPreview${i}`);
                const pCtx = previewCanvas.getContext('2d');
                const cfg = carConfigs[i];
                const w = 60, h = 100;

                // Dark road background
                pCtx.fillStyle = '#1a1a2e';
                pCtx.fillRect(0, 0, w, h);

                // Subtle road lines
                pCtx.strokeStyle = 'rgba(255,255,255,0.06)';
                pCtx.lineWidth = 1;
                pCtx.setLineDash([8, 6]);
                pCtx.beginPath(); pCtx.moveTo(w/2, 0); pCtx.lineTo(w/2, h); pCtx.stroke();
                pCtx.setLineDash([]);

                // Draw car using the new context-agnostic helper
                pCtx.save();
                pCtx.translate(w / 2, h / 2);
                drawFns[i](pCtx, w, h, cfg);
                pCtx.restore();
            }
            selectCar(0);
        }

        // Render previews as soon as page loads
        renderCarPreviews();

        function startGame() {
            initAudio();
            startScreen.style.display = 'none';
            gameStarted = true;
            gameOver = false;
            score = 0;
            speed = 60;
            obstacles = [];
            coinItems = [];
            coinTrails = [];
            coinTimer = 0;
            coins = 0;
            coinCombo = 0;
            comboTimer = 0;
            bestCombo = 0;
            lives = 3;
            invincible = false;
            invincibleTimer = 0;
            powerUps = [];
            powerUpTimer = 0;
            hazards = [];
            hazardTimer = 0;
            oilSlipTimer = 0;
            potholeSlowTimer = 0;
            shieldActive = false;
            shieldTimer = 0;
            magnetActive = false;
            magnetTimer = 0;
            floatingTexts = [];
            particles = [];
            exhaustPuffs = [];
            skidMarks = [];
            turboTrails = [];
            shakeAmount = 0;
            shakeDuration = 0;
            timeScale = 1.0;
            slowMoTimer = 0;
            turboActive = false;
            turboTimer = 0;
            turboCharge = 0;
            weatherIndex = 0;
            weatherTimer = 0;
            nightAlpha = 0;
            rainAlpha = 0;
            raindrops = [];
            weatherLabel = '';
            weatherLabelTimer = 0;
            level = 1;
            levelFlash = 0;
            levelDisplay.textContent = '‚≠ê Rookie';
            coinDisplay.textContent = 0;
            livesDisplay.textContent = '‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è';
            player.currentLane = 1;
            targetLane = 1;
            carTilt = 0;
            player.x = lanes[1] - player.width / 2;
            scoreDisplay.textContent = 0;
            topSpeed = 0;
            closeCallCount = 0;
            runStartTime = Date.now();

            gameLoop();
        }

        function restartGame() {
            gameOverScreen.classList.remove('show');
            startGame();
        }

        function drawRoad() {
            // Road background
            ctx.fillStyle = '#3d3d5c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Lane lines (dashed)
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 3;
            ctx.setLineDash([20, 20]);
            ctx.lineDashOffset = -roadOffset;
            
            for (let i = 1; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(i * laneWidth, 0);
                ctx.lineTo(i * laneWidth, canvas.height);
                ctx.stroke();
            }

            // Road edges (Altius orange)
            ctx.setLineDash([]);
            ctx.strokeStyle = '#FF6347';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(5, 0);
            ctx.lineTo(5, canvas.height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(canvas.width - 5, 0);
            ctx.lineTo(canvas.width - 5, canvas.height);
            ctx.stroke();

            roadOffset += (speed * timeScale) / 10;
            if (roadOffset > 40) roadOffset = 0;

            // Night mode overlay - gradually darkens road
            if (nightAlpha > 0) {
                ctx.fillStyle = `rgba(0, 0, 10, ${nightAlpha * 0.82})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function drawHeadlights() {
            if (nightAlpha <= 0) return;
            const cx = player.x + player.width / 2;
            const cy = player.y;

            ctx.save();
            ctx.globalAlpha = nightAlpha;

            // Left beam
            const leftGrad = ctx.createRadialGradient(cx - 8, cy, 2, cx - 8, cy - canvas.height * 0.55, canvas.height * 0.6);
            leftGrad.addColorStop(0, 'rgba(255, 255, 200, 0.55)');
            leftGrad.addColorStop(0.35, 'rgba(255, 255, 180, 0.18)');
            leftGrad.addColorStop(1, 'rgba(255, 255, 150, 0)');
            ctx.beginPath();
            ctx.moveTo(cx - 8, cy);
            ctx.lineTo(cx - 8 - canvas.width * 0.38, cy - canvas.height * 0.75);
            ctx.lineTo(cx + canvas.width * 0.02, cy - canvas.height * 0.75);
            ctx.closePath();
            ctx.fillStyle = leftGrad;
            ctx.fill();

            // Right beam
            const rightGrad = ctx.createRadialGradient(cx + 8, cy, 2, cx + 8, cy - canvas.height * 0.55, canvas.height * 0.6);
            rightGrad.addColorStop(0, 'rgba(255, 255, 200, 0.55)');
            rightGrad.addColorStop(0.35, 'rgba(255, 255, 180, 0.18)');
            rightGrad.addColorStop(1, 'rgba(255, 255, 150, 0)');
            ctx.beginPath();
            ctx.moveTo(cx + 8, cy);
            ctx.lineTo(cx - canvas.width * 0.02, cy - canvas.height * 0.75);
            ctx.lineTo(cx + 8 + canvas.width * 0.38, cy - canvas.height * 0.75);
            ctx.closePath();
            ctx.fillStyle = rightGrad;
            ctx.fill();

            ctx.restore();
        }

        function drawPlayerCar(x, y, width, height, carCfg) {
            const cfg = carCfg || carConfigs[selectedCar];
            const carType = carConfigs.indexOf(cfg);
            ctx.save();
            ctx.translate(x + width / 2, y + height / 2);

            if (carType === 1) {
                // --- F1 Car (Stealth) ---
                drawF1Car(ctx, width, height, cfg);
            } else if (carType === 2) {
                // --- Hypercar (Blaze) ---
                drawHyperCar(ctx, width, height, cfg);
            } else {
                // --- Lamborghini GT (Altius GT, default) ---
                drawLamboCar(ctx, width, height, cfg);
            }

            ctx.restore();
        }

        function drawLamboCar(C, w, h, cfg) {
            // Sharp angular Lambo Aventador silhouette (top-down)
            const hw = w / 2, hh = h / 2;

            // Shadow
            C.fillStyle = 'rgba(0,0,0,0.25)';
            C.beginPath();
            C.ellipse(2, 4, hw - 2, hh - 4, 0, 0, Math.PI * 2);
            C.fill();

            // Main body ‚Äî angular wedge
            C.fillStyle = cfg.body;
            C.beginPath();
            C.moveTo(0, -hh);                    // nose tip
            C.lineTo(hw * 0.55, -hh * 0.7);      // front-right
            C.lineTo(hw * 0.9,  -hh * 0.2);      // mid-right shoulder
            C.lineTo(hw,         hh * 0.2);       // widest right
            C.lineTo(hw * 0.85,  hh * 0.75);      // rear-right
            C.lineTo(hw * 0.4,   hh);             // tail-right
            C.lineTo(-hw * 0.4,  hh);             // tail-left
            C.lineTo(-hw * 0.85, hh * 0.75);
            C.lineTo(-hw,        hh * 0.2);
            C.lineTo(-hw * 0.9, -hh * 0.2);
            C.lineTo(-hw * 0.55,-hh * 0.7);
            C.closePath();
            C.fill();

            // Accent side skirts
            C.fillStyle = cfg.accent;
            C.fillRect(-hw, -hh * 0.1, 6, hh * 0.55);
            C.fillRect(hw - 6, -hh * 0.1, 6, hh * 0.55);

            // Hood panel lines
            C.strokeStyle = cfg.accent;
            C.lineWidth = 1.5;
            C.globalAlpha = 0.5;
            C.beginPath();
            C.moveTo(0, -hh); C.lineTo(-hw * 0.3, -hh * 0.4); C.lineTo(-hw * 0.3, -hh * 0.1);
            C.moveTo(0, -hh); C.lineTo( hw * 0.3, -hh * 0.4); C.lineTo( hw * 0.3, -hh * 0.1);
            C.stroke();
            C.globalAlpha = 1;

            // Cockpit glass
            C.fillStyle = cfg.glass;
            C.globalAlpha = 0.88;
            C.beginPath();
            C.moveTo(-hw * 0.38, -hh * 0.15);
            C.lineTo( hw * 0.38, -hh * 0.15);
            C.lineTo( hw * 0.28,  hh * 0.28);
            C.lineTo(-hw * 0.28,  hh * 0.28);
            C.closePath();
            C.fill();
            C.globalAlpha = 1;

            // Interior seat silhouette
            C.fillStyle = 'rgba(0,0,0,0.5)';
            C.beginPath();
            C.ellipse(0, hh * 0.05, hw * 0.18, hh * 0.22, 0, 0, Math.PI * 2);
            C.fill();

            // Rear wing
            C.fillStyle = cfg.spoiler;
            C.fillRect(-hw, hh * 0.72, w, 5);
            C.fillRect(-hw * 0.7, hh * 0.65, hw * 0.15, hh * 0.12);
            C.fillRect( hw * 0.55, hh * 0.65, hw * 0.15, hh * 0.12);

            // LED headlights ‚Äî sharp blade style
            C.shadowColor = '#fff';
            C.shadowBlur = 8;
            C.fillStyle = '#fffde7';
            // Left blade
            C.beginPath();
            C.moveTo(-hw * 0.55, -hh * 0.72);
            C.lineTo(-hw * 0.1, -hh * 0.88);
            C.lineTo(-hw * 0.1, -hh * 0.82);
            C.lineTo(-hw * 0.52, -hh * 0.65);
            C.closePath(); C.fill();
            // Right blade
            C.beginPath();
            C.moveTo(hw * 0.55, -hh * 0.72);
            C.lineTo(hw * 0.1, -hh * 0.88);
            C.lineTo(hw * 0.1, -hh * 0.82);
            C.lineTo(hw * 0.52, -hh * 0.65);
            C.closePath(); C.fill();
            C.shadowBlur = 0;

            // Tail lights ‚Äî full-width LED strip
            C.fillStyle = '#ff1a1a';
            C.shadowColor = '#ff0000';
            C.shadowBlur = 10;
            C.fillRect(-hw * 0.85, hh * 0.82, w * 0.85 * 2, 5);
            C.shadowBlur = 0;

            // Wheels
            C.fillStyle = '#111';
            [[-hw * 0.88, -hh * 0.45], [hw * 0.88, -hh * 0.45],
             [-hw * 0.88,  hh * 0.52], [hw * 0.88,  hh * 0.52]].forEach(([wx, wy]) => {
                C.beginPath(); C.ellipse(wx, wy, 5, 7, 0, 0, Math.PI * 2); C.fill();
                C.strokeStyle = '#555'; C.lineWidth = 1;
                C.beginPath(); C.ellipse(wx, wy, 3, 4, 0, 0, Math.PI * 2); C.stroke();
            });
        }

        function drawF1Car(C, w, h, cfg) {
            const hw = w / 2, hh = h / 2;

            // Shadow
            C.fillStyle = 'rgba(0,0,0,0.22)';
            C.beginPath(); C.ellipse(1, 3, hw - 4, hh - 6, 0, 0, Math.PI * 2); C.fill();

            // Long narrow nose cone
            C.fillStyle = cfg.body;
            C.beginPath();
            C.moveTo(0, -hh);
            C.lineTo(hw * 0.22, -hh * 0.6);
            C.lineTo(hw * 0.38, -hh * 0.2);
            C.lineTo(hw * 0.5,  hh * 0.1);
            C.lineTo(hw * 0.4,  hh * 0.65);
            C.lineTo(-hw * 0.4, hh * 0.65);
            C.lineTo(-hw * 0.5, hh * 0.1);
            C.lineTo(-hw * 0.38,-hh * 0.2);
            C.lineTo(-hw * 0.22,-hh * 0.6);
            C.closePath(); C.fill();

            // Front wing ‚Äî wide flat bar
            C.fillStyle = cfg.accent;
            C.fillRect(-hw, -hh * 0.55, w, 5);
            C.fillRect(-hw * 0.85, -hh * 0.6, hw * 0.85 * 2, 3);

            // Sidepods
            C.fillStyle = cfg.body;
            C.fillRect(-hw, -hh * 0.15, 10, hh * 0.6);
            C.fillRect(hw - 10, -hh * 0.15, 10, hh * 0.6);
            C.fillStyle = cfg.accent;
            C.fillRect(-hw, -hh * 0.1, 10, 4);
            C.fillRect(hw - 10, -hh * 0.1, 10, 4);

            // Open cockpit bubble
            C.fillStyle = cfg.glass;
            C.globalAlpha = 0.9;
            C.beginPath();
            C.ellipse(0, -hh * 0.08, hw * 0.3, hh * 0.25, 0, 0, Math.PI * 2);
            C.fill();
            C.globalAlpha = 1;

            // Helmet
            C.fillStyle = cfg.accent;
            C.beginPath(); C.ellipse(0, -hh * 0.08, hw * 0.14, hh * 0.14, 0, 0, Math.PI * 2); C.fill();

            // Shark fin
            C.fillStyle = cfg.spoiler;
            C.beginPath();
            C.moveTo(0, hh * 0.1); C.lineTo(hw * 0.04, hh * 0.55); C.lineTo(-hw * 0.04, hh * 0.55);
            C.closePath(); C.fill();

            // Rear wing ‚Äî double element
            C.fillStyle = cfg.accent;
            C.fillRect(-hw * 0.48, hh * 0.55, hw * 0.48 * 2, 5);
            C.fillRect(-hw * 0.48, hh * 0.6, hw * 0.48 * 2, 3);
            C.fillStyle = cfg.spoiler;
            C.fillRect(-hw * 0.5, hh * 0.5, 5, hh * 0.18);
            C.fillRect(hw * 0.45, hh * 0.5, 5, hh * 0.18);

            // Headlights (halo style)
            C.strokeStyle = '#fffde7'; C.lineWidth = 2;
            C.shadowColor = '#fff'; C.shadowBlur = 8;
            C.beginPath(); C.arc(0, -hh * 0.78, hw * 0.2, Math.PI * 1.1, Math.PI * 1.9); C.stroke();
            C.shadowBlur = 0;

            // Tail lights
            C.fillStyle = '#ff1a1a'; C.shadowColor = '#f00'; C.shadowBlur = 8;
            C.fillRect(-hw * 0.4, hh * 0.62, hw * 0.8 * 2, 4);
            C.shadowBlur = 0;

            // Big outer wheels
            [[-hw, -hh * 0.35], [hw, -hh * 0.35],
             [-hw, hh * 0.35],  [hw,  hh * 0.35]].forEach(([wx, wy]) => {
                C.fillStyle = '#111';
                C.beginPath(); C.ellipse(wx, wy, 7, 9, 0, 0, Math.PI * 2); C.fill();
                C.strokeStyle = '#444'; C.lineWidth = 1.5;
                C.beginPath(); C.ellipse(wx, wy, 4, 5, 0, 0, Math.PI * 2); C.stroke();
            });
        }

        function drawHyperCar(C, w, h, cfg) {
            // Bugatti Chiron / Koenigsegg vibe ‚Äî wide, organic, twin-bubble canopy
            const hw = w / 2, hh = h / 2;

            // Shadow
            C.fillStyle = 'rgba(0,0,0,0.22)';
            C.beginPath(); C.ellipse(2, 4, hw - 1, hh - 5, 0, 0, Math.PI * 2); C.fill();

            // Body ‚Äî very wide organic shape
            C.fillStyle = cfg.body;
            C.beginPath();
            C.moveTo(0, -hh);
            C.bezierCurveTo(hw * 0.6, -hh, hw, -hh * 0.4, hw, 0);
            C.bezierCurveTo(hw, hh * 0.6, hw * 0.7, hh, 0, hh);
            C.bezierCurveTo(-hw * 0.7, hh, -hw, hh * 0.6, -hw, 0);
            C.bezierCurveTo(-hw, -hh * 0.4, -hw * 0.6, -hh, 0, -hh);
            C.fill();

            // Accent C-stripe
            C.strokeStyle = cfg.accent;
            C.lineWidth = 3;
            C.globalAlpha = 0.85;
            C.beginPath();
            C.moveTo(-hw * 0.9, -hh * 0.1);
            C.bezierCurveTo(-hw * 0.8, -hh * 0.5, -hw * 0.2, -hh * 0.8, hw * 0.3, -hh * 0.6);
            C.stroke();
            C.beginPath();
            C.moveTo(hw * 0.9, -hh * 0.1);
            C.bezierCurveTo(hw * 0.8, -hh * 0.5, hw * 0.2, -hh * 0.8, -hw * 0.3, -hh * 0.6);
            C.stroke();
            C.globalAlpha = 1;

            // Twin-bubble glass
            C.fillStyle = cfg.glass;
            C.globalAlpha = 0.85;
            C.beginPath(); C.ellipse(-hw * 0.22, -hh * 0.08, hw * 0.22, hh * 0.28, 0, 0, Math.PI * 2); C.fill();
            C.beginPath(); C.ellipse( hw * 0.22, -hh * 0.08, hw * 0.22, hh * 0.28, 0, 0, Math.PI * 2); C.fill();
            C.globalAlpha = 1;

            // Centre spine
            C.fillStyle = cfg.spoiler;
            C.fillRect(-2, -hh * 0.3, 4, hh * 1.1);

            // Rear diffuser fins
            C.fillStyle = cfg.accent;
            for (let i = -3; i <= 3; i++) {
                C.fillRect(i * 5 - 1, hh * 0.7, 2, hh * 0.28);
            }

            // Rear wing
            C.fillStyle = cfg.spoiler;
            C.fillRect(-hw * 0.7, hh * 0.68, hw * 1.4, 5);

            // Quad headlights
            C.shadowColor = '#fff'; C.shadowBlur = 8;
            C.fillStyle = '#fffde7';
            [[-hw * 0.52, -hh * 0.78], [-hw * 0.24, -hh * 0.82],
             [ hw * 0.52, -hh * 0.78], [ hw * 0.24, -hh * 0.82]].forEach(([lx, ly]) => {
                C.beginPath(); C.ellipse(lx, ly, 5, 3, 0, 0, Math.PI * 2); C.fill();
            });
            C.shadowBlur = 0;

            // Tail lights
            C.fillStyle = '#ff1a1a'; C.shadowColor = '#f00'; C.shadowBlur = 10;
            C.beginPath(); C.ellipse(-hw * 0.55, hh * 0.78, 7, 3, 0, 0, Math.PI * 2); C.fill();
            C.beginPath(); C.ellipse( hw * 0.55, hh * 0.78, 7, 3, 0, 0, Math.PI * 2); C.fill();
            C.shadowBlur = 0;

            // Wheels
            [[-hw * 0.88, -hh * 0.52], [hw * 0.88, -hh * 0.52],
             [-hw * 0.88,  hh * 0.6],  [hw * 0.88,  hh * 0.6]].forEach(([wx, wy]) => {
                C.fillStyle = '#111';
                C.beginPath(); C.ellipse(wx, wy, 6, 8, 0, 0, Math.PI * 2); C.fill();
                C.strokeStyle = '#555'; C.lineWidth = 1;
                C.beginPath(); C.ellipse(wx, wy, 3, 4, 0, 0, Math.PI * 2); C.stroke();
            });
        }

        // 4 modern obstacle car styles
        function drawObstacleCar(C, x, y, w, h, carType, color, nightAlpha) {
            C.save();
            C.translate(x + w / 2, y + h / 2);
            const hw = w / 2, hh = h / 2;

            if (carType === 0) {
                // --- Modern Sedan (BMW / Mercedes style) ---
                // Shadow
                C.fillStyle = 'rgba(0,0,0,0.2)';
                C.beginPath(); C.ellipse(1, 3, hw - 2, hh - 4, 0, 0, Math.PI * 2); C.fill();

                // Body
                C.fillStyle = color;
                C.beginPath();
                C.moveTo(-hw * 0.6, -hh);
                C.lineTo( hw * 0.6, -hh);
                C.bezierCurveTo(hw, -hh, hw, -hh * 0.7, hw, -hh * 0.5);
                C.lineTo(hw, hh * 0.6);
                C.bezierCurveTo(hw, hh, hw * 0.7, hh, 0, hh);
                C.bezierCurveTo(-hw * 0.7, hh, -hw, hh, -hw, hh * 0.6);
                C.lineTo(-hw, -hh * 0.5);
                C.bezierCurveTo(-hw, -hh * 0.7, -hw, -hh, -hw * 0.6, -hh);
                C.closePath(); C.fill();

                // Roof cabin (sloped sedan profile)
                C.fillStyle = 'rgba(0,0,0,0.35)';
                C.beginPath();
                C.moveTo(-hw * 0.5,  hh * 0.05);
                C.lineTo(-hw * 0.35, -hh * 0.45);
                C.lineTo( hw * 0.35, -hh * 0.45);
                C.lineTo( hw * 0.5,   hh * 0.05);
                C.closePath(); C.fill();

                // Windshield
                C.fillStyle = '#a8d8f0'; C.globalAlpha = 0.75;
                C.beginPath();
                C.moveTo(-hw * 0.38, -hh * 0.4);
                C.lineTo( hw * 0.38, -hh * 0.4);
                C.lineTo( hw * 0.32,  hh * 0.02);
                C.lineTo(-hw * 0.32,  hh * 0.02);
                C.closePath(); C.fill();
                // Rear window (sloped)
                C.beginPath();
                C.moveTo(-hw * 0.42, hh * 0.1);
                C.lineTo( hw * 0.42, hh * 0.1);
                C.lineTo( hw * 0.35, hh * 0.42);
                C.lineTo(-hw * 0.35, hh * 0.42);
                C.closePath(); C.fill();
                C.globalAlpha = 1;

                // Headlights ‚Äî thin LED strip
                C.fillStyle = '#fffde7'; C.shadowColor = '#fff'; C.shadowBlur = 8;
                C.fillRect(-hw * 0.7, -hh * 0.9, hw * 0.55, 4);
                C.fillRect( hw * 0.15, -hh * 0.9, hw * 0.55, 4);
                C.shadowBlur = 0;
                // Tail lights
                C.fillStyle = '#ff2200'; C.shadowColor = '#f00'; C.shadowBlur = 8;
                C.fillRect(-hw * 0.7, hh * 0.82, hw * 0.55, 4);
                C.fillRect( hw * 0.15, hh * 0.82, hw * 0.55, 4);
                C.shadowBlur = 0;

                // Wheels
                [[-hw * 0.8, -hh * 0.5], [hw * 0.8, -hh * 0.5],
                 [-hw * 0.8,  hh * 0.55],[hw * 0.8,  hh * 0.55]].forEach(([wx, wy]) => {
                    C.fillStyle = '#111'; C.beginPath(); C.ellipse(wx, wy, 5, 6, 0, 0, Math.PI * 2); C.fill();
                    C.strokeStyle = '#444'; C.lineWidth = 1;
                    C.beginPath(); C.ellipse(wx, wy, 3, 4, 0, 0, Math.PI * 2); C.stroke();
                });

            } else if (carType === 1) {
                // --- SUV / Crossover (Range Rover / Porsche Cayenne style) ---
                // Shadow
                C.fillStyle = 'rgba(0,0,0,0.25)';
                C.beginPath(); C.ellipse(1, 4, hw - 1, hh - 4, 0, 0, Math.PI * 2); C.fill();

                // Tall boxy body with slight taper
                C.fillStyle = color;
                C.beginPath();
                C.moveTo(-hw * 0.7, -hh);
                C.lineTo( hw * 0.7, -hh);
                C.lineTo( hw, -hh * 0.6);
                C.lineTo( hw, hh * 0.7);
                C.lineTo( hw * 0.6, hh);
                C.lineTo(-hw * 0.6, hh);
                C.lineTo(-hw, hh * 0.7);
                C.lineTo(-hw, -hh * 0.6);
                C.closePath(); C.fill();

                // Tall roof ‚Äî nearly straight
                C.fillStyle = 'rgba(0,0,0,0.3)';
                C.fillRect(-hw * 0.62, -hh * 0.55, w * 0.62 * 2, hh * 0.95);

                // Large windshield (SUV = big glass)
                C.fillStyle = '#a8d8f0'; C.globalAlpha = 0.7;
                C.fillRect(-hw * 0.52, -hh * 0.5, w * 0.52 * 2, hh * 0.45);
                // Rear glass
                C.fillRect(-hw * 0.52, hh * 0.05, w * 0.52 * 2, hh * 0.38);
                C.globalAlpha = 1;

                // Roof rails
                C.strokeStyle = 'rgba(255,255,255,0.25)'; C.lineWidth = 1.5;
                C.beginPath(); C.moveTo(-hw * 0.4, -hh * 0.55); C.lineTo(-hw * 0.4, hh * 0.42); C.stroke();
                C.beginPath(); C.moveTo( hw * 0.4, -hh * 0.55); C.lineTo( hw * 0.4, hh * 0.42); C.stroke();

                // Chunky headlights
                C.fillStyle = '#fffde7'; C.shadowColor = '#fff'; C.shadowBlur = 8;
                C.fillRect(-hw * 0.72, -hh * 0.95, hw * 0.5, 6);
                C.fillRect( hw * 0.22, -hh * 0.95, hw * 0.5, 6);
                C.shadowBlur = 0;
                // Tail lights
                C.fillStyle = '#ff2200'; C.shadowColor = '#f00'; C.shadowBlur = 8;
                C.fillRect(-hw * 0.72, hh * 0.88, hw * 0.5, 5);
                C.fillRect( hw * 0.22, hh * 0.88, hw * 0.5, 5);
                C.shadowBlur = 0;

                // Big chunky wheels
                [[-hw * 0.85, -hh * 0.55], [hw * 0.85, -hh * 0.55],
                 [-hw * 0.85,  hh * 0.6],  [hw * 0.85,  hh * 0.6]].forEach(([wx, wy]) => {
                    C.fillStyle = '#111'; C.beginPath(); C.ellipse(wx, wy, 7, 8, 0, 0, Math.PI * 2); C.fill();
                    C.strokeStyle = '#555'; C.lineWidth = 1.5;
                    C.beginPath(); C.ellipse(wx, wy, 4, 5, 0, 0, Math.PI * 2); C.stroke();
                });

            } else if (carType === 2) {
                // --- Sports Coupe (Porsche 911 / Ferrari Roma style) ---
                // Shadow
                C.fillStyle = 'rgba(0,0,0,0.2)';
                C.beginPath(); C.ellipse(1, 3, hw - 3, hh - 6, 0, 0, Math.PI * 2); C.fill();

                // Wide low body
                C.fillStyle = color;
                C.beginPath();
                C.moveTo(0, -hh);
                C.bezierCurveTo(hw * 0.5, -hh, hw, -hh * 0.55, hw, -hh * 0.1);
                C.bezierCurveTo(hw, hh * 0.55, hw * 0.6, hh, 0, hh);
                C.bezierCurveTo(-hw * 0.6, hh, -hw, hh * 0.55, -hw, -hh * 0.1);
                C.bezierCurveTo(-hw, -hh * 0.55, -hw * 0.5, -hh, 0, -hh);
                C.fill();

                // Long fastback roof
                C.fillStyle = 'rgba(0,0,0,0.4)';
                C.beginPath();
                C.moveTo(-hw * 0.55, hh * 0.35);
                C.bezierCurveTo(-hw * 0.5, -hh * 0.15, -hw * 0.3, -hh * 0.5, 0, -hh * 0.55);
                C.bezierCurveTo(hw * 0.3, -hh * 0.5, hw * 0.5, -hh * 0.15, hw * 0.55, hh * 0.35);
                C.closePath(); C.fill();

                // Glass ‚Äî wrap-around
                C.fillStyle = '#7ec8e3'; C.globalAlpha = 0.8;
                C.beginPath();
                C.moveTo(-hw * 0.45, hh * 0.3);
                C.bezierCurveTo(-hw * 0.4, -hh * 0.1, -hw * 0.25, -hh * 0.45, 0, -hh * 0.5);
                C.bezierCurveTo(hw * 0.25, -hh * 0.45, hw * 0.4, -hh * 0.1, hw * 0.45, hh * 0.3);
                C.closePath(); C.fill();
                C.globalAlpha = 1;

                // Round headlights (911 circular)
                C.fillStyle = '#fffde7'; C.shadowColor = '#fff'; C.shadowBlur = 10;
                C.beginPath(); C.ellipse(-hw * 0.42, -hh * 0.72, 6, 5, 0, 0, Math.PI * 2); C.fill();
                C.beginPath(); C.ellipse( hw * 0.42, -hh * 0.72, 6, 5, 0, 0, Math.PI * 2); C.fill();
                C.shadowBlur = 0;
                // Tail lights ‚Äî wide
                C.fillStyle = '#ff2200'; C.shadowColor = '#f00'; C.shadowBlur = 10;
                C.fillRect(-hw * 0.55, hh * 0.75, w * 0.55 * 2, 4);
                C.shadowBlur = 0;

                // Wheels
                [[-hw * 0.85, -hh * 0.48], [hw * 0.85, -hh * 0.48],
                 [-hw * 0.85,  hh * 0.55], [hw * 0.85,  hh * 0.55]].forEach(([wx, wy]) => {
                    C.fillStyle = '#111'; C.beginPath(); C.ellipse(wx, wy, 6, 7, 0, 0, Math.PI * 2); C.fill();
                    C.strokeStyle = '#555'; C.lineWidth = 1;
                    C.beginPath(); C.ellipse(wx, wy, 3, 4, 0, 0, Math.PI * 2); C.stroke();
                });

            } else {
                // --- Pickup Truck (Ford F-150 / RAM style) ---
                // Shadow
                C.fillStyle = 'rgba(0,0,0,0.25)';
                C.beginPath(); C.ellipse(1, 4, hw, hh - 4, 0, 0, Math.PI * 2); C.fill();

                // Truck bed (rear half)
                C.fillStyle = color;
                C.fillRect(-hw, hh * 0.0, w, hh * 0.95);
                // Cab (front half)
                C.fillRect(-hw * 0.75, -hh, w * 0.75, hh * 1.1);

                // Bed rails
                C.strokeStyle = 'rgba(0,0,0,0.4)'; C.lineWidth = 2;
                C.strokeRect(-hw * 0.95, hh * 0.05, w * 0.95, hh * 0.85);

                // Cab roof
                C.fillStyle = 'rgba(0,0,0,0.3)';
                C.fillRect(-hw * 0.7, -hh * 0.92, w * 0.7, hh * 0.8);

                // Windshield
                C.fillStyle = '#a8d8f0'; C.globalAlpha = 0.7;
                C.fillRect(-hw * 0.58, -hh * 0.85, w * 0.58, hh * 0.52);
                C.globalAlpha = 1;

                // Grille stripe
                C.fillStyle = 'rgba(0,0,0,0.5)';
                C.fillRect(-hw * 0.65, -hh * 0.97, w * 0.65, 7);
                C.fillStyle = 'rgba(255,255,255,0.15)';
                C.fillRect(-hw * 0.6, -hh * 0.95, w * 0.6, 3);

                // Headlights
                C.fillStyle = '#fffde7'; C.shadowColor = '#fff'; C.shadowBlur = 8;
                C.fillRect(-hw * 0.75, -hh * 0.98, hw * 0.25, 5);
                C.fillRect( hw * 0.05, -hh * 0.98, hw * 0.25, 5);
                C.shadowBlur = 0;
                // Tail lights
                C.fillStyle = '#ff2200'; C.shadowColor = '#f00'; C.shadowBlur = 8;
                C.fillRect(-hw * 0.95, hh * 0.88, hw * 0.28, 5);
                C.fillRect( hw * 0.25, hh * 0.88, hw * 0.28, 5);
                C.shadowBlur = 0;

                // Bigger wheels
                [[-hw * 0.82, -hh * 0.5], [hw * 0.82, -hh * 0.5],
                 [-hw * 0.82,  hh * 0.6], [hw * 0.82,  hh * 0.6]].forEach(([wx, wy]) => {
                    C.fillStyle = '#111'; C.beginPath(); C.ellipse(wx, wy, 7, 8, 0, 0, Math.PI * 2); C.fill();
                    C.strokeStyle = '#555'; C.lineWidth = 1.5;
                    C.beginPath(); C.ellipse(wx, wy, 4, 5, 0, 0, Math.PI * 2); C.stroke();
                });
            }

            // Glowing headlight beams at night
            if (nightAlpha > 0.3) {
                const beamAlpha = nightAlpha * 0.4;
                C.save();
                C.globalAlpha = beamAlpha;
                C.fillStyle = '#fffde7';
                C.shadowColor = '#fff';
                C.shadowBlur = 15 * nightAlpha;
                
                // Draw conical beams based on car type
                if (carType === 3) {
                    // Pickup - wide apart
                    C.beginPath();
                    C.moveTo(-hw * 0.75, -hh * 0.98);
                    C.lineTo(-hw * 0.8, -hh * 1.8);
                    C.lineTo(-hw * 0.6, -hh * 1.6);
                    C.closePath();
                    C.fill();
                    C.beginPath();
                    C.moveTo(hw * 0.2, -hh * 0.98);
                    C.lineTo(hw * 0.6, -hh * 1.6);
                    C.lineTo(hw * 0.8, -hh * 1.8);
                    C.closePath();
                    C.fill();
                } else if (carType === 1) {
                    // SUV - wide beams
                    C.beginPath();
                    C.moveTo(-hw * 0.65, -hh * 0.95);
                    C.lineTo(-hw * 0.75, -hh * 1.8);
                    C.lineTo(-hw * 0.4, -hh * 1.5);
                    C.closePath();
                    C.fill();
                    C.beginPath();
                    C.moveTo(hw * 0.45, -hh * 0.95);
                    C.lineTo(hw * 0.4, -hh * 1.5);
                    C.lineTo(hw * 0.75, -hh * 1.8);
                    C.closePath();
                    C.fill();
                } else {
                    // Sedan / Coupe - standard beams
                    C.beginPath();
                    C.moveTo(-hw * 0.48, -hh * 0.85);
                    C.lineTo(-hw * 0.6, -hh * 1.7);
                    C.lineTo(-hw * 0.3, -hh * 1.5);
                    C.closePath();
                    C.fill();
                    C.beginPath();
                    C.moveTo(hw * 0.48, -hh * 0.85);
                    C.lineTo(hw * 0.3, -hh * 1.5);
                    C.lineTo(hw * 0.6, -hh * 1.7);
                    C.closePath();
                    C.fill();
                }
                C.restore();
            }

            C.restore();
        }

        function createObstacle() {
            const colors = ['#c0392b','#2980b9','#27ae60','#8e44ad','#d35400','#2c3e50','#c0a020','#1a6b4a'];
            const lane = lanes[Math.floor(Math.random() * lanes.length)];
            obstacles.push({
                x: lane - 20,
                y: -70,
                width: 40,
                height: 70,
                color: colors[Math.floor(Math.random() * colors.length)],
                carType: Math.floor(Math.random() * 4)
            });
        }

        function createCoin() {
            const lane = lanes[Math.floor(Math.random() * lanes.length)];
            coinItems.push({
                x: lane,
                y: -20,
                radius: 18
            });
        }

        function drawCoins() {
            for (let coin of coinItems) {
                const r = coin.radius;
                const cx = coin.x;
                const cy = coin.y;

                ctx.save();

                // Clip everything to the coin circle
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.clip();

                // Coin face - red metallic gradient
                const grad = ctx.createRadialGradient(cx - r * 0.3, cy - r * 0.3, r * 0.05, cx, cy, r);
                grad.addColorStop(0, '#ff9977');
                grad.addColorStop(0.5, '#ee4422');
                grad.addColorStop(1, '#bb2200');
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();

                // Draw the actual Altius logo using multiply so black marks show on coin
                if (logoLoaded) {
                    const size = r * 1.5;
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.drawImage(altiusLogo, cx - size / 2, cy - size / 2, size, size);
                    ctx.globalCompositeOperation = 'source-over';
                }

                ctx.restore();

                // Outer rim on top
                ctx.save();
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.strokeStyle = '#ff6644';
                ctx.lineWidth = 2.5;
                ctx.stroke();

                // Shine highlight
                ctx.beginPath();
                ctx.arc(cx - r * 0.25, cy - r * 0.3, r * 0.25, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.fill();
                ctx.restore();
            }
        }

        function updateCoins() {
            coinTimer++;
            if (coinTimer > coinInterval) {
                createCoin();
                coinTimer = 0;
            }

            for (let i = coinItems.length - 1; i >= 0; i--) {
                coinItems[i].y += (speed * timeScale) / 10;

                if (coinItems[i].y > canvas.height) {
                    coinItems.splice(i, 1);
                    // Miss breaks the combo
                    if (coinCombo >= 3) {
                        spawnFloatingText(
                            lanes[player.currentLane],
                            player.y,
                            'üíî COMBO LOST!', '#ff6666'
                        );
                    }
                    coinCombo = 0;
                    comboTimer = 0;
                }
            }

        }

        function drawCoinTrails() {}

        function checkCoinCollection() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            for (let i = coinItems.length - 1; i >= 0; i--) {
                const coin = coinItems[i];
                const dx = playerCenterX - coin.x;
                const dy = playerCenterY - coin.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Magnet pulls ALL coins on screen strongly toward player
                if (magnetActive) {
                    coin.x += dx * 0.08;
                    coin.y += dy * 0.08;
                }

                // Collect if close enough
                const collectDist = magnetActive ? 25 : coin.radius + player.width / 2;
                if (dist < collectDist) {
                    spawnFloatingText(coin.x, coin.y, '+1 ü™ô', '#ffd700');
                    playCoinSound();
                    coinItems.splice(i, 1);
                    coins++;
                    coinDisplay.textContent = coins;

                    // Combo logic
                    coinCombo++;
                    comboTimer = comboWindow;
                    if (coinCombo > bestCombo) bestCombo = coinCombo;

                    // Milestone bonuses
                    if (coinCombo === 3) {
                        score += 15;
                        spawnFloatingText(coin.x, coin.y - 28, 'üî• COMBO x3! +15', '#ff9900');
                    } else if (coinCombo === 5) {
                        score += 30;
                        spawnFloatingText(coin.x, coin.y - 28, '‚ö° COMBO x5! +30', '#ff4400');
                    } else if (coinCombo === 10) {
                        score += 60;
                        spawnFloatingText(coin.x, coin.y - 28, 'üí• COMBO x10! +60', '#ff0000');
                    } else if (coinCombo > 10 && coinCombo % 5 === 0) {
                        score += 50;
                        spawnFloatingText(coin.x, coin.y - 28, `üåü COMBO x${coinCombo}! +50`, '#ff00ff');
                    } else if (coinCombo > 3) {
                        spawnFloatingText(coin.x, coin.y - 22, `üî• x${coinCombo}`, '#ffaa00');
                    }
                    scoreDisplay.textContent = score;
                }
            }
        }

        function spawnFloatingText(x, y, text, color) {
            floatingTexts.push({
                x, y,
                text,
                color,
                alpha: 1.0,
                scale: 1.0,
                vy: -2.2,  // float upward
                life: 55   // frames
            });
        }

        function drawFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const f = floatingTexts[i];
                f.y += f.vy;
                f.vy *= 0.96; // slow down as it rises
                f.alpha -= 1 / f.life;
                f.scale = 0.8 + 0.4 * (f.alpha); // shrink as it fades
                f.life--;

                if (f.life <= 0) {
                    floatingTexts.splice(i, 1);
                    continue;
                }

                ctx.save();
                ctx.globalAlpha = Math.max(0, f.alpha);
                ctx.font = `bold ${Math.round(16 * f.scale)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Shadow for readability
                ctx.shadowColor = 'rgba(0,0,0,0.8)';
                ctx.shadowBlur = 4;
                ctx.fillStyle = f.color;
                ctx.fillText(f.text, f.x, f.y);
                ctx.restore();
            }
        }

        function spawnExhaust() {
            const cx = player.x + player.width / 2;
            const cy = player.y + player.height * 0.92; // rear of car

            // Pick puff color based on weather / turbo
            let color;
            const r = rainAlpha;
            const n = nightAlpha;
            if (turboActive) {
                // Turbo: bright fire orange/red
                const flicker = Math.floor(Math.random() * 55);
                color = `rgba(255, ${80 + flicker}, 0, 0.8)`;
            } else if (r > 0.4) {
                // Rain: cool blue-grey steam
                color = `rgba(${160 + Math.floor(Math.random()*30)}, ${190 + Math.floor(Math.random()*30)}, ${220 + Math.floor(Math.random()*35)}, 0.55)`;
            } else if (n > 0.4) {
                // Night: dark grey/blue smoke
                color = `rgba(${80 + Math.floor(Math.random()*40)}, ${80 + Math.floor(Math.random()*40)}, ${120 + Math.floor(Math.random()*40)}, 0.5)`;
            } else {
                // Day: warm orange-grey heat shimmer
                color = `rgba(${200 + Math.floor(Math.random()*55)}, ${130 + Math.floor(Math.random()*60)}, ${60 + Math.floor(Math.random()*40)}, 0.4)`;
            }

            // Two exhaust pipes, slight spread
            for (let side of [-5, 5]) {
                exhaustPuffs.push({
                    x: cx + side + (Math.random() - 0.5) * 4,
                    y: cy,
                    vx: (Math.random() - 0.5) * 0.8,
                    vy: 1.5 + Math.random() * 1.5,   // drifts downward (away from car)
                    radius: 3 + Math.random() * 3,
                    color,
                    alpha: 0.55,
                    life: 22 + Math.floor(Math.random() * 14)
                });
            }
        }

        function drawExhaust() {
            for (let i = exhaustPuffs.length - 1; i >= 0; i--) {
                const p = exhaustPuffs[i];
                p.x += p.vx;
                p.y += p.vy;
                p.radius += 0.22;        // puff grows
                p.alpha -= 1 / p.life;
                p.life--;
                if (p.life <= 0 || p.alpha <= 0) { exhaustPuffs.splice(i, 1); continue; }
                ctx.save();
                ctx.globalAlpha = Math.max(0, p.alpha);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
                ctx.restore();
            }
        }

        // Skid marks - tyre rubber on lane changes
        function createSkidMark() {
            // Create rubber marks from rear tyres
            const rearY = player.y + player.height * 0.6;
            const tirePositions = [
                { x: player.x + 8, y: rearY },
                { x: player.x + player.width - 8, y: rearY }
            ];
            
            for (let tire of tirePositions) {
                skidMarks.push({
                    x: tire.x,
                    y: tire.y,
                    width: 4,
                    length: 0,
                    maxLength: 35 + Math.random() * 15,
                    alpha: 0.7,
                    fade: 0.012
                });
            }
        }

        function updateSkidMarks() {
            for (let i = skidMarks.length - 1; i >= 0; i--) {
                const mark = skidMarks[i];
                mark.y += (speed * timeScale) / 10;
                
                // Grow the mark
                if (mark.length < mark.maxLength) {
                    mark.length += 2.5;
                } else {
                    mark.alpha -= mark.fade;
                }
                
                if (mark.alpha <= 0 || mark.y > canvas.height) {
                    skidMarks.splice(i, 1);
                }
            }
        }

        function drawSkidMarks() {
            ctx.save();
            for (let mark of skidMarks) {
                ctx.globalAlpha = mark.alpha;
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(mark.x - mark.width / 2, mark.y - mark.length, mark.width, mark.length);
            }
            ctx.restore();
        }

        // Turbo fire trails - orange flames shooting backward
        function spawnTurboTrail() {
            if (!turboActive) return;
            const rearY = player.y + player.height * 0.85;
            const positions = [
                { x: player.x + 12, y: rearY },
                { x: player.x + player.width - 12, y: rearY }
            ];
            
            for (let pos of positions) {
                turboTrails.push({
                    x: pos.x + (Math.random() - 0.5) * 6,
                    y: pos.y,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: 3 + Math.random() * 4,
                    radius: 3 + Math.random() * 4,
                    color: Math.random() < 0.7 ? '#ff6600' : '#ffaa00',
                    alpha: 1.0,
                    life: 12 + Math.floor(Math.random() * 8)
                });
            }
        }

        function updateTurboTrails() {
            for (let i = turboTrails.length - 1; i >= 0; i--) {
                const t = turboTrails[i];
                t.x += t.vx;
                t.y += t.vy;
                t.radius *= 0.92;
                t.alpha -= 1 / t.life;
                t.life--;
                if (t.life <= 0 || t.alpha <= 0) turboTrails.splice(i, 1);
            }
        }

        function drawTurboTrails() {
            ctx.save();
            for (let t of turboTrails) {
                ctx.globalAlpha = Math.max(0, t.alpha);
                ctx.beginPath();
                ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
                ctx.fillStyle = t.color;
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 8;
                ctx.fill();
            }
            ctx.restore();
        }

        function spawnExplosion(x, y) {
            const colors = ['#FF6347', '#ffd700', '#ff4444', '#ffaa00', '#ffffff', '#ff8800'];
            for (let i = 0; i < 28; i++) {
                const angle = (Math.PI * 2 / 28) * i + (Math.random() - 0.5) * 0.4;
                const speed = 2.5 + Math.random() * 4;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 2.5 + Math.random() * 4,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    alpha: 1.0,
                    gravity: 0.15,
                    life: 35 + Math.floor(Math.random() * 25)
                });
            }
            // Shockwave ring
            particles.push({
                type: 'ring',
                x, y,
                radius: 5,
                maxRadius: 55,
                alpha: 0.9,
                life: 22
            });
        }

        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life--;

                if (p.type === 'ring') {
                    p.radius += (p.maxRadius - p.radius) * 0.18;
                    p.alpha -= 0.04;
                    if (p.life <= 0 || p.alpha <= 0) { particles.splice(i, 1); continue; }
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 150, 50, ${p.alpha})`;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 10;
                    ctx.stroke();
                    ctx.restore();
                } else {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += p.gravity;
                    p.vx *= 0.97;
                    p.alpha -= 1 / p.life;
                    p.radius *= 0.97;
                    if (p.life <= 0 || p.alpha <= 0) { particles.splice(i, 1); continue; }
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, p.alpha);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 6;
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        function createPowerUp() {
            const lane = lanes[Math.floor(Math.random() * lanes.length)];
            const type = Math.random() < 0.5 ? 'shield' : 'magnet';
            powerUps.push({ x: lane, y: -20, radius: 18, type });
        }

        function drawPowerUps() {
            for (let p of powerUps) {
                ctx.save();

                // Clip to circle
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.clip();

                // Background gradient
                const isShield = p.type === 'shield';
                const grad = ctx.createRadialGradient(p.x - p.radius * 0.3, p.y - p.radius * 0.3, 2, p.x, p.y, p.radius);
                if (isShield) {
                    grad.addColorStop(0, '#88eeff');
                    grad.addColorStop(1, '#0088cc');
                } else {
                    grad.addColorStop(0, '#ffe066');
                    grad.addColorStop(1, '#cc7700');
                }
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.restore();

                // Icon
                ctx.save();
                ctx.font = `${p.radius * 1.1}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(isShield ? 'üõ°Ô∏è' : 'üß≤', p.x, p.y);

                // Outer glow ring
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.strokeStyle = isShield ? '#00ccff' : '#ffcc00';
                ctx.lineWidth = 2.5;
                ctx.stroke();
                ctx.restore();
            }
        }

        function updatePowerUps() {
            powerUpTimer++;
            if (powerUpTimer > powerUpInterval) {
                createPowerUp();
                powerUpTimer = 0;
            }
            for (let i = powerUps.length - 1; i >= 0; i--) {
                powerUps[i].y += (speed * timeScale) / 10;
                if (powerUps[i].y > canvas.height) powerUps.splice(i, 1);
            }

            // Count down active power-ups
            if (shieldActive) {
                shieldTimer--;
                if (shieldTimer <= 0) {
                    shieldActive = false;
                }
            }
            if (magnetActive) {
                magnetTimer--;
                if (magnetTimer <= 0) {
                    magnetActive = false;
                }
            }
        }

        function checkPowerUpCollection() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                const dx = playerCenterX - p.x;
                const dy = playerCenterY - p.y;
                if (Math.sqrt(dx * dx + dy * dy) < p.radius + player.width / 2) {
                    powerUps.splice(i, 1);
                    if (p.type === 'shield') {
                        shieldActive = true;
                        shieldTimer = powerUpDuration;
                        spawnFloatingText(p.x, p.y, 'üõ°Ô∏è SHIELD!', '#00ccff');
                        playPowerUpSound();
                    } else {
                        magnetActive = true;
                        magnetTimer = powerUpDuration;
                        spawnFloatingText(p.x, p.y, 'üß≤ MAGNET!', '#ffcc00');
                        playPowerUpSound();
                    }
                }
            }
        }

        // Road Hazards
        function createHazard() {
            const type = Math.random() < 0.5 ? 'oil' : 'pothole';
            const lane = lanes[Math.floor(Math.random() * lanes.length)];
            hazards.push({
                x: lane - 25,
                y: -40,
                width: 50,
                height: 40,
                type
            });
        }

        function updateHazards() {
            hazardTimer++;
            if (hazardTimer > hazardInterval) {
                createHazard();
                hazardTimer = 0;
            }
            for (let i = hazards.length - 1; i >= 0; i--) {
                hazards[i].y += (speed * timeScale) / 10;
                if (hazards[i].y > canvas.height) hazards.splice(i, 1);
            }

            // Effect timers
            if (oilSlipTimer > 0) oilSlipTimer--;
            if (potholeSlowTimer > 0) potholeSlowTimer--;
        }

        function drawHazards() {
            for (let h of hazards) {
                ctx.save();
                if (h.type === 'oil') {
                    // Oil slick - dark puddle with rainbow sheen
                    const grad = ctx.createRadialGradient(h.x + h.width/2, h.y + h.height/2, 5, h.x + h.width/2, h.y + h.height/2, h.width/2);
                    grad.addColorStop(0, 'rgba(40, 40, 50, 0.85)');
                    grad.addColorStop(0.6, 'rgba(20, 20, 30, 0.75)');
                    grad.addColorStop(1, 'rgba(10, 10, 20, 0.4)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.ellipse(h.x + h.width/2, h.y + h.height/2, h.width/2, h.height/2.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Rainbow sheen effect
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = `hsl(${(Date.now() / 10) % 360}, 80%, 60%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    // Pothole - cracked road
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(h.x + 5, h.y + 5, h.width - 10, h.height - 10);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    // Crack lines
                    ctx.beginPath();
                    ctx.moveTo(h.x + 8, h.y + 10); ctx.lineTo(h.x + h.width - 12, h.y + h.height - 8);
                    ctx.moveTo(h.x + h.width - 8, h.y + 12); ctx.lineTo(h.x + 10, h.y + h.height - 10);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        function checkHazardCollision() {
            if (oilSlipTimer > 0 || potholeSlowTimer > 0) return; // already affected
            for (let i = hazards.length - 1; i >= 0; i--) {
                const h = hazards[i];
                if (player.x < h.x + h.width &&
                    player.x + player.width > h.x &&
                    player.y < h.y + h.height &&
                    player.y + player.height > h.y) {
                    hazards.splice(i, 1);
                    if (h.type === 'oil') {
                        oilSlipTimer = 90; // 1.5 seconds
                        spawnFloatingText(player.x + player.width/2, player.y - 15, 'üíß SLIPPING!', '#666');
                    } else {
                        potholeSlowTimer = 75; // 1.25 seconds
                        shakeAmount = 6;
                        shakeDuration = 15;
                        spawnFloatingText(player.x + player.width/2, player.y - 15, 'üï≥Ô∏è BUMP!', '#888');
                    }
                }
            }
        }

        function drawPowerUpTimers() {
            const barW = 90;
            const barH = 14;
            const radius = 7;
            let yPos = 12;

            const drawTimer = (label, emoji, timer, color, yOffset) => {
                const x = canvas.width - barW - 8;
                const y = yOffset;
                const pct = timer / powerUpDuration;
                const secsLeft = Math.ceil(timer / 60);

                // Background bar
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(x, y, barW, barH);

                // Fill bar
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 6;
                ctx.fillRect(x, y, barW * pct, barH);
                ctx.shadowBlur = 0;

                // Label + seconds
                ctx.font = 'bold 9px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${emoji} ${secsLeft}s`, x + 5, y + barH / 2);

                ctx.restore();
            };

            if (shieldActive) {
                drawTimer('Shield', 'üõ°Ô∏è', shieldTimer, '#00ccff', yPos);
                yPos += barH + 5;
            }
            if (magnetActive) {
                drawTimer('Magnet', 'üß≤', magnetTimer, '#ffcc00', yPos);
            }
        }


        function updateObstacles() {
            obstacleTimer++;
            if (obstacleTimer > obstacleInterval - speed / 2) {
                createObstacle();
                obstacleTimer = 0;
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].y += (speed * timeScale) / 10;

                // Close call detection: obstacle passes through player Y zone but doesn't hit
                if (!obstacles[i].closeCalled &&
                    !invincible && !shieldActive &&
                    obstacles[i].y + obstacles[i].height > player.y &&
                    obstacles[i].y < player.y + player.height) {
                    const ox = obstacles[i].x + obstacles[i].width / 2;
                    const px = player.x + player.width / 2;
                    const xDist = Math.abs(ox - px);
                    // Within danger zone but not actually colliding
                    if (xDist > player.width / 2 + obstacles[i].width / 2 &&
                        xDist < player.width + obstacles[i].width) {
                        obstacles[i].closeCalled = true;
                        closeCallCount++;
                        if (!turboActive) {
                            slowMoTimer = slowMoDuration;
                        }
                        spawnFloatingText(player.x + player.width / 2, player.y - 10, 'üòÖ CLOSE!', '#ff9900');
                    }
                }

                if (obstacles[i].y > canvas.height) {
                    obstacles.splice(i, 1);
                    score += 10;
                    scoreDisplay.textContent = score;
                    if (score > highScore) {
                        highScore = score;
                        highScoreDisplay.textContent = highScore;
                    }

                    // Check level up
                    for (let lvl = levelThresholds.length - 1; lvl >= 1; lvl--) {
                        if (score >= levelThresholds[lvl] && level < lvl) {
                            level = lvl;
                            levelDisplay.textContent = `‚≠ê ${levelNames[level]}`;
                            levelFlash = 120; // 2 second flash
                            playLevelUpSound();
                            spawnFloatingText(canvas.width / 2, canvas.height / 2, `LEVEL UP! ${levelNames[level]}`, '#ffd700');
                            break;
                        }
                    }
                    
                    // Increase speed more gradually - max 300
                    if (score % 30 === 0 && speed < 300) {
                        speed += 4;
                    }
                }
            }
        }

        function checkCollision() {
            for (let obstacle of obstacles) {
                if (player.x < obstacle.x + obstacle.width &&
                    player.x + player.width > obstacle.x &&
                    player.y < obstacle.y + obstacle.height &&
                    player.y + player.height > obstacle.y) {
                    return true;
                }
            }
            return false;
        }

        function drawLevelFlash() {
            if (levelFlash <= 0) return;

            const alpha = levelFlash > 90
                ? (120 - levelFlash) / 30        // fade in
                : levelFlash / 90;                // fade out

            // Full screen golden overlay
            ctx.save();
            ctx.globalAlpha = alpha * 0.35;
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1;

            // Level name badge
            const badgeW = 280, badgeH = 60;
            const bx = (canvas.width - badgeW) / 2;
            const by = canvas.height / 2 - 70;

            ctx.globalAlpha = alpha;
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            ctx.fillRect(bx, by, badgeW, badgeH);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(bx, by, badgeW, badgeH);

            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = '#ffd700';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚≠ê LEVEL UP ‚≠ê', canvas.width / 2, by + 18);

            ctx.font = `bold 20px Arial`;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(levelNames[level], canvas.width / 2, by + 42);

            ctx.restore();

            levelFlash--;
        }

        function updateRain() {
            if (rainAlpha <= 0.05) { raindrops = []; return; }
            // Spawn new drops proportional to rain intensity
            const spawnCount = Math.floor(rainAlpha * 5);
            for (let i = 0; i < spawnCount; i++) {
                raindrops.push({
                    x: Math.random() * canvas.width,
                    y: -10,
                    len: 10 + Math.random() * 14,
                    speed: 12 + Math.random() * 8,
                    alpha: 0.3 + Math.random() * 0.5
                });
            }
            for (let i = raindrops.length - 1; i >= 0; i--) {
                raindrops[i].y += raindrops[i].speed;
                if (raindrops[i].y > canvas.height) raindrops.splice(i, 1);
            }
        }

        function drawRain() {
            if (rainAlpha <= 0.05) return;
            ctx.save();
            ctx.globalAlpha = rainAlpha * 0.7;
            ctx.strokeStyle = '#aaddff';
            ctx.lineWidth = 1;
            for (let d of raindrops) {
                ctx.globalAlpha = d.alpha * rainAlpha;
                ctx.beginPath();
                ctx.moveTo(d.x, d.y);
                ctx.lineTo(d.x - 1, d.y + d.len);
                ctx.stroke();
            }
            // Wet road shimmer
            ctx.globalAlpha = rainAlpha * 0.12;
            ctx.fillStyle = '#88ccff';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
            ctx.restore();
        }

        function drawSpeedBlur() {
            const intensity = Math.max(0, (speed - 100) / 200); // starts at 100 km/h
            if (intensity <= 0) return;

            // Dark vignette edges
            const vignette = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height * 0.25,
                canvas.width / 2, canvas.height / 2, canvas.height * 0.85
            );
            vignette.addColorStop(0, `rgba(0,0,0,0)`);
            vignette.addColorStop(1, `rgba(0,0,0,${intensity * 0.65})`);
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Speed streak lines on edges
            const streakCount = Math.floor(intensity * 14);
            ctx.save();
            ctx.strokeStyle = `rgba(255,255,255,${intensity * 0.12})`;
            ctx.lineWidth = 1;
            for (let i = 0; i < streakCount; i++) {
                const x = Math.random() < 0.5
                    ? Math.random() * canvas.width * 0.18
                    : canvas.width - Math.random() * canvas.width * 0.18;
                const y = Math.random() * canvas.height;
                const len = 18 + Math.random() * 30 * intensity;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + len);
                ctx.stroke();
            }
            ctx.restore();

            // Red warning tint at max speed
            if (speed >= 250) {
                const pulse = 0.06 + 0.04 * Math.sin(Date.now() / 120);
                ctx.fillStyle = `rgba(255,0,0,${pulse})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function drawComboMeter() {
            if (coinCombo < 2) return;

            const barW = 100;
            const barH = 12;
            const x = canvas.width / 2 - barW / 2;
            const y = canvas.height - 28;
            const pct = comboTimer / comboWindow;

            // Background
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.55)';
            ctx.fillRect(x - 2, y - 2, barW + 4, barH + 4);

            // Fill ‚Äî colour shifts red‚Üíorange‚Üígold as combo grows
            const r = 255;
            const g = Math.min(255, Math.floor(80 + coinCombo * 12));
            ctx.fillStyle = `rgb(${r},${g},0)`;
            ctx.shadowColor = `rgb(${r},${g},0)`;
            ctx.shadowBlur = 8;
            ctx.fillRect(x, y, barW * pct, barH);
            ctx.shadowBlur = 0;

            // Label
            ctx.font = 'bold 11px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`üî• COMBO x${coinCombo}`, canvas.width / 2, y - 9);
            ctx.restore();
        }

        function drawSlowMoOverlay() {
            if (slowMoTimer <= 0) return;
            const alpha = (slowMoTimer / slowMoDuration) * 0.35;
            // Cool blue tint
            ctx.save();
            ctx.fillStyle = `rgba(0, 120, 255, ${alpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // "SLOW MO" text fading in
            if (slowMoTimer > slowMoDuration * 0.6) {
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(150, 220, 255, ${alpha * 2})`;
                ctx.shadowColor = '#00aaff';
                ctx.shadowBlur = 12;
                ctx.fillText('‚ö° NEAR MISS!', canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        function drawTurboBar() {
            if (!gameStarted) return;
            const barW = 110, barH = 12;
            const x = canvas.width / 2 - barW / 2;
            const y = canvas.height - 16;
            const pct = turboCharge / turboMaxCharge;

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(x - 1, y - 1, barW + 2, barH + 2);

            // Fill
            if (turboActive) {
                // Pulsing orange during turbo
                const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.02);
                ctx.fillStyle = `rgba(255, ${Math.floor(80 * pulse)}, 0, 1)`;
                ctx.shadowColor = '#ff4400';
                ctx.shadowBlur = 10;
                ctx.fillRect(x, y, barW * (turboTimer / turboDuration), barH);
                ctx.shadowBlur = 0;
            } else {
                const r = pct >= 1 ? 80 : 255;
                const g = pct >= 1 ? 255 : Math.floor(140 * pct);
                ctx.fillStyle = `rgb(${r}, ${g}, 0)`;
                if (pct >= 1) {
                    ctx.shadowColor = '#00ff80';
                    ctx.shadowBlur = 8;
                }
                ctx.fillRect(x, y, barW * pct, barH);
                ctx.shadowBlur = 0;
            }

            // Label
            ctx.save();
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = pct >= 1 && !turboActive ? '#00ff80' : '#ffffff';
            ctx.fillText(turboActive ? 'üöÄ TURBO!' : pct >= 1 ? 'üöÄ READY! [SPACE]' : `üöÄ ${Math.floor(pct * 100)}%`, canvas.width / 2, y - 3);
            ctx.restore();
        }

        function gameLoop() {
            if (!gameStarted || gameOver) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Smooth lane switching animation
            const targetX = lanes[targetLane] - player.width / 2;
            const diffX = targetX - player.x;
            if (Math.abs(diffX) > 0.5) {
                player.x += diffX * laneTransitionSpeed;
                // Calculate tilt based on movement direction
                carTilt = Math.sign(diffX) * Math.min(Math.abs(diffX) * 0.08, 8);
            } else {
                player.x = targetX;
                carTilt *= 0.85; // gradually straighten out
                if (Math.abs(carTilt) < 0.1) carTilt = 0;
            }

            // Apply screen shake
            ctx.save();
            if (shakeDuration > 0) {
                const sx = (Math.random() - 0.5) * shakeAmount;
                const sy = (Math.random() - 0.5) * shakeAmount;
                ctx.translate(sx, sy);
                shakeAmount *= 0.85;
                shakeDuration--;
                if (shakeDuration <= 0) shakeAmount = 0;
            }

            drawRoad();
            drawHazards();
            
            // Skid marks on road
            updateSkidMarks();
            drawSkidMarks();

            // ---- Weather cycle update ----
            weatherTimer++;
            if (weatherTimer >= weatherDuration) {
                weatherTimer = 0;
                weatherIndex = (weatherIndex + 1) % weatherStates.length;
                const labels = { day: '‚òÄÔ∏è DAYTIME!', night: 'üåô NIGHT!', rain: 'üåßÔ∏è RAIN!' };
                const colors = { day: '#ffe066', night: '#aaaaff', rain: '#88ccff' };
                const w = weatherStates[weatherIndex];
                spawnFloatingText(canvas.width / 2, canvas.height / 2 - 20, labels[w], colors[w]);
                weatherLabel = labels[w];
                weatherLabelTimer = 180;
            }

            const currentWeather = weatherStates[weatherIndex];
            // Night alpha
            const targetNight = currentWeather === 'night' ? 1 : (currentWeather === 'rain' ? 0.45 : 0);
            nightAlpha += (targetNight - nightAlpha) * 0.012;
            // Rain alpha
            const targetRain = currentWeather === 'rain' ? 1 : 0;
            rainAlpha += (targetRain - rainAlpha) * 0.015;
            
            // --- Time scale management ---
            if (turboActive) {
                turboTimer--;
                timeScale = turboScale;
                if (turboTimer <= 0) {
                    turboActive = false;
                    timeScale = 1.0;
                }
            } else if (slowMoTimer > 0) {
                slowMoTimer--;
                timeScale = slowMoScale + (1.0 - slowMoScale) * (1 - slowMoTimer / slowMoDuration);
                if (slowMoTimer <= 0) timeScale = 1.0;
            } else {
                timeScale = 1.0;
            }

            // Pothole slowdown effect
            if (potholeSlowTimer > 0) {
                timeScale *= 0.5; // 50% speed reduction
            }

            // Turbo charge (only fills when not turbo active)
            if (!turboActive && turboCharge < turboMaxCharge) {
                turboCharge = Math.min(turboMaxCharge, turboCharge + turboChargeRate);
            }

            // Update speed display
            speedDisplay.textContent = Math.round(speed * timeScale);
            if (speed > topSpeed) topSpeed = speed;

            updateCoins();
            updateObstacles();
            updatePowerUps();
            updateHazards();
            checkCoinCollection();
            checkPowerUpCollection();
            checkHazardCollision();

            // Draw coin trails then coins
            drawCoinTrails();
            drawCoins();

            // Draw floating text animations
            drawFloatingTexts();

            // Draw explosion particles
            drawParticles();

            // Draw power-ups
            drawPowerUps();

            // Exhaust trail (drawn behind car)
            const exhaustRate = turboActive ? 1.0 : 0.8;
            if (Math.random() < exhaustRate) spawnExhaust();
            if (turboActive && Math.random() < 0.7) spawnExhaust(); // extra puffs
            drawExhaust();

            // Turbo fire trails (during boost)
            if (turboActive && Math.random() < 0.85) spawnTurboTrail();
            updateTurboTrails();
            drawTurboTrails();

            // Draw player car - flash when hit-invincible
            if (!invincible || Math.floor(invincibleTimer / 8) % 2 === 0) {
                ctx.save();
                ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                ctx.rotate(carTilt * Math.PI / 180);
                ctx.translate(-(player.x + player.width / 2), -(player.y + player.height / 2));
                drawPlayerCar(player.x, player.y, player.width, player.height);
                ctx.restore();
            }

            // Headlight beams in night mode
            drawHeadlights();

            // Shield aura around car
            if (shieldActive) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(player.x + player.width / 2, player.y + player.height / 2, player.width * 0.85, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 200, 255, ${0.4 + 0.3 * Math.sin(Date.now() / 150)})`;
                ctx.lineWidth = 4;
                ctx.shadowColor = '#00ccff';
                ctx.shadowBlur = 12;
                ctx.stroke();
                ctx.restore();
            }

            // Draw obstacle cars
            for (let obstacle of obstacles) {
                drawObstacleCar(ctx, obstacle.x, obstacle.y, obstacle.width, obstacle.height, obstacle.carType || 0, obstacle.color, nightAlpha);
            }

            // Rain (drawn over road and cars)
            updateRain();
            drawRain();

            // Draw power-up countdown timers on canvas
            if (shieldActive || magnetActive) drawPowerUpTimers();

            // Combo meter at bottom
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer <= 0) {
                    if (coinCombo >= 3) {
                        spawnFloatingText(
                            canvas.width / 2, player.y,
                            'üíî COMBO LOST!', '#ff6666'
                        );
                    }
                    coinCombo = 0;
                }
            }
            drawComboMeter();

            // Slow-mo blue tint overlay
            drawSlowMoOverlay();

            // Turbo charge bar
            drawTurboBar();

            // Draw level-up flash
            drawLevelFlash();

            // Speed blur overlay (drawn on top of everything)
            drawSpeedBlur();

            // Persistent weather icon (top-left)
            ctx.save();
            ctx.font = '18px serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            const wIcons = { day: '‚òÄÔ∏è', night: 'üåô', rain: 'üåßÔ∏è' };
            ctx.fillText(wIcons[weatherStates[weatherIndex]] || '‚òÄÔ∏è', 8, 10);
            ctx.restore();

            // Restore shake transform
            ctx.restore();

            // Check collision - shield blocks damage
            if (checkCollision() && !invincible && !shieldActive) {
                spawnExplosion(player.x + player.width / 2, player.y + player.height / 2);
                playCrashSound();
                shakeAmount = 10;
                shakeDuration = 30;
                lives--;
                const lifeIcons = ['üíÄ', '‚ù§Ô∏èüñ§üñ§', '‚ù§Ô∏è‚ù§Ô∏èüñ§', '‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è'];
                livesDisplay.textContent = lifeIcons[lives] || 'üíÄ';

                // Funny crash quips
                const quips = score < 50
                    ? ["REALLY?! üò≠", "BRO üíÄ", "NOT AGAIN üò§", "HOW?! üòÇ", "SKILL ISSUE üíÄ"]
                    : ["OUCH! üò¨", "SO CLOSE! üò§", "STAY FOCUSED! üëÄ", "NOT LIKE THIS! üò©"];
                spawnFloatingText(
                    player.x + player.width / 2,
                    player.y - 20,
                    quips[Math.floor(Math.random() * quips.length)],
                    score < 50 ? '#ff4444' : '#ff9900'
                );

                if (lives <= 0) {
                    gameOver = true;
                    const runSecs = Math.floor((Date.now() - runStartTime) / 1000);
                    const runMins = runSecs / 60;
                    const cpm = runMins > 0 ? Math.round(coins / runMins) : coins;

                    finalScoreDisplay.textContent   = score;
                    finalLevelDisplay.textContent   = levelNames[level];
                    finalCoinsDisplay.textContent   = coins;
                    finalTopSpeedDisplay.textContent = `${Math.round(topSpeed)} km/h`;
                    finalCloseCallDisplay.textContent = closeCallCount;
                    finalTimeDisplay.textContent    = runSecs >= 60
                        ? `${Math.floor(runSecs/60)}m ${runSecs%60}s`
                        : `${runSecs}s`;
                    finalCPMDisplay.textContent     = cpm;
                    finalHighScoreDisplay.textContent = highScore;
                    finalBestComboDisplay.textContent = bestCombo;

                    // Run rating + roast mode
                    const roasts = {
                        tragic: [
                            "Bro hit the first car and called it a day üíÄ",
                            "My grandma drives faster. She's 94. In a wheelchair. üê¢",
                            "Did you even TRY? üò≠",
                            "Parked car: 1, You: 0 üöóüí•",
                            "The road called. It said it doesn't want you back.",
                            "I've seen snails with better reaction time. üêå",
                            "That was ROUGH. Like, painfully rough. üò¨",
                        ],
                        bad: [
                            "You survived longer than expected. Barely. üòÖ",
                            "A solid attempt. By toddler standards. üë∂",
                            "The obstacles weren't even trying hard. üöß",
                            "Your car misses you. It's in the scrapyard now. üîß",
                            "Points: low. Confidence: lower. Keep going! üíî",
                        ],
                        mid: [
                            "Mid run. Literally. üòê",
                            "Not bad! Not good either though. üëÄ",
                            "You're improving! (Starting from zero helps.) üìà",
                            "Average enjoyer behaviour. ü§∑",
                        ],
                        good: [
                            "Okay okay, respect. ü§úü§õ",
                            "You might actually be good at this. üò§",
                            "The road fears you. A little bit. üèéÔ∏è",
                        ],
                        elite: [
                            "Stop playing, are you cheating? üëÄ",
                            "Respectfully, please touch grass. üåø",
                            "You need a life. Also a trophy. üèÜ",
                        ]
                    };

                    let rating = '';
                    let roast = '';
                    const pick = arr => arr[Math.floor(Math.random() * arr.length)];

                    if (score >= 500) {
                        rating = 'üèÜ LEGEND!';
                        roast = pick(roasts.elite);
                    } else if (score >= 300) {
                        rating = 'üî• Elite Driver!';
                        roast = pick(roasts.good);
                    } else if (score >= 200) {
                        rating = '‚≠ê Pro Racer!';
                        roast = pick(roasts.good);
                    } else if (score >= 100) {
                        rating = 'üëç Getting There!';
                        roast = pick(roasts.mid);
                    } else if (score >= 50) {
                        rating = 'üò¨ Rough Start';
                        roast = pick(roasts.bad);
                    } else {
                        rating = 'üíÄ CATASTROPHIC';
                        roast = pick(roasts.tragic);
                    }

                    runRatingDisplay.textContent = rating;
                    roastMsgDisplay.textContent = `"${roast}"`;

                    // Check and save high score
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('altiusTurboHighScore', highScore);
                        highScoreDisplay.textContent = highScore;
                        finalHighScoreDisplay.textContent = highScore;
                        newHighScoreMsg.style.display = 'block';
                    } else {
                        newHighScoreMsg.style.display = 'none';
                    }

                    gameOverScreen.classList.add('show');
                    return;
                }

                // Trigger invincibility flash
                invincible = true;
                invincibleTimer = invincibleDuration;
            }

            // Invincibility countdown
            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) invincible = false;
            }

            requestAnimationFrame(gameLoop);
        }

        // Safety & Transparency Functions
        function openSafetyModal() {
            document.getElementById('safetyModal').style.display = 'block';
        }

        function closeSafetyModal() {
            document.getElementById('safetyModal').style.display = 'none';
        }

        function viewSourceCode() {
            // Opens the page source in a new tab
            window.open('view-source:' + window.location.href, '_blank');
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('safetyModal');
            if (e.target === modal) {
                closeSafetyModal();
            }
        });
    </script>
</body>
</html>